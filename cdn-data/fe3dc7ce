#  Task310. Архитектурный стиль REST (основы)

### Дано: 
- Разрабатываемая система обрабатывает сущности **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**, которые логически связаны отношениями 
  - один-ко-многим (**{{Author}}** и **{{News}}**, **{{News}}** и **{{Comment}}**) 
  - многие-ко-многим (**{{News}}**, **{{Tag}}**). 
- Необходимо разработать решение в архитектурном стиле REST, с учетом перспективы развития приложения.

> Ожидается смена версий api в будущих заданиях. При такой смене будет новый префикс и (возможно) 
> порт. Данная работа выбрана как стартовая для автоматизированной проверки этой и последующих работ. 
> Проверяйте тщательно разработанный функционал. 
> 
> Тему REST мы скорее всего будем проходить еще раз, более углубленно, с дополнительными 
> возможностями поиска, пагинации, частичной модификации 
> и поддержкой [HATEOAS](https://ru.wikipedia.org/wiki/HATEOAS).

### Задание

- Основой для задания является следующая схема приложения:

![Entities-app](media/310.svg)

![designations](../common/svg/uml.svg)

- Модель данных:
  - Необходимо создать сущности, указанные на схеме 
    - **{{Author}}**
    - **{{News}}**
    - **{{Tag}}**
    - **{{Comment}}**
    - при необходимости можно использовать общую абстракцию для сущностей
- Необходимо создать DTO:
  - для входных параметров (запросов)
    - **{{Author}}RequestTo**
    - **{{News}}RequestTo**
    - **{{Tag}}RequestTo**
    - **{{Comment}}RequestTo**
  - выходного результата (ответов)
    - **{{Author}}ResponseTo**  
    - **{{News}}ResponseTo** 
    - **{{Tag}}ResponseTo** 
    - **{{Comment}}ResponseTo**
  - важно, чтобы DTO имели такие названия для внутренних нужд backend, а на слое представления (в json) были ожидаемые названия сущностей, а именно: **{{author}}**, **{{news}}**, **{{tag}}** и **{{comment}}**.
- Слой хранения:
  - Создайте обобщенный интерфейс для хранения и поиска данных сущностей для **CRUD** операций.
  - Создайте InMemory имплементацию разработанного интерфейса (например, в виде коллекции Map) для сущностей **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**.
- Слой сервисов: 
  - Создайте сервисы для объектов **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**.
  - Реализуйте в сервисах бизнес-логику (CRUD) для обработки данных объектов
  - Реализуйте в сервисах преобразование объектов DTO в сущности (при запросах) и обратно (для ответов). Рекомендуется использовать готовое решение, например MapStruct
- Слой контроллеров:
  - Создайте контроллеры REST для объектов **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**.
  - Важно чтобы итоговые REST-контроллеры генерировали ответы с ошибками при нарушении указанных ограничений. 
  - При реализации обработчика исключений для контроллеров REST можно использовать аннотацию **@ControllerAdvice**.
  - Контроллеры REST должны поддерживать операции [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) для вышеупомянутых объектов, т.е. должны реализовать такой функционал:
    - Поддержка поиска **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}** по ключевому полю **{{id}}**.
    - Поддержка создания сущностей **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**.
    - Поддержка изменения **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}**.
    - Поддержка удаления **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}** по ключевому полю **{{id}}**.
- Дополнительные функции (в этой версии пока не требуются, удобнее их реализовывать, когда будет подключена база данных, но можно уже планировать их на будущее)
  - Поддержка частичной модификации **{{Author}}**, **{{News}}**, **{{Tag}}** и **{{Comment}}** с помощью PATCH HTTP Verb.
  - Поддержка поиска **{{Author}}** по ключевому полю **{{id}}** сущности **{{News}}**.
  - Поддержка поиска коллекции **{{Tag}}** по ключевому полю **{{id}}** сущности **{{News}}**.
  - Поддержка поиска **{{Comment}}** по ключевому полю **{{id}}** сущности **{{News}}**.
  - Поддержка поиска коллекции **{{News}}** по полю **{{name}}** сущности **{{Tag}}**.
  - Поддержка поиска коллекции **{{News}}** по ключевому полю **{{id}}** сущностей **{{Tag}}**, **{{login}}** **{{Author}}**
  - Поддержка поиска коллекции **{{News}}** по полю **{{name}}** сущности **{{Tag}}**, по ключевому полю **{{id}}** сущностей **{{Tag}}**, **{{login}}** **{{Author}}**, заголовку, содержанию (все параметры необязательны и могут использоваться
    совместно).
  - Все запросы в перспективе будут поддерживать фильтрацию, пагинацию, сортировку.
- Проверка входных параметров (запросов) методов контроллера REST должна возвращать ошибку с кодом возврата 4xx, если параметры имеют недопустимые значения.

### Технические требования

- **ВАЖНО!** Используйте префикс **/api/v1.0/** для контроллеров REST и их методов,
- **ВАЖНО!** Используйте адрес и порт **localhost:24110** для самого приложения.

### Рекомендации

#### Возможные решения

- В качестве языка программирования для backend лучше всего использовать язык Java с его экосиситемой (Maven, Spring, Mapstruct и т.д.)
- Вы можете создавать свои собственные интерфейсы REST-контроллера, сервисов и слоя хранения, рекомендуется заранее продумать их структуру для максимальной универсальности.
- Используйте Spring Boot starter: `org.springframework.boot:spring-boot-starter-web` для реализации функций REST - это наиболее простой путь решения.
- По согласованию с руководителем/ментором/тренером/лектором/преподавателем курса можно попробовать использовать другие языки программирования (не рекомендуется).

#### Ожидаемые операции

Система должна предоставлять операции CRUD для {{News}}, {{Author}}, {{Tag}}, {{Comment}}:

- [x] Create {{News}} - передаются все поля, кроме id и меток времени, затем возвращается {{news}} как dto response, http response status - 201.
- [x] Create {{Author}} - передаются все поля, кроме id, затем возвращается {{author}} как dto response, http response status - 201.
- [x] Create {{Tag}} - заполняется поле {{name}} in {{tag}}, затем возвращается {{tag}} как dto response, http response status - 201.
- [x] Create {{Comment}} - заполняются поле {{content}} и {{news}}Id в {{comment}}, затем возвращается  {{comment}} как dto response,
  http response status - 201.

- [x] Get {{News}}s – возвращает список всех {{news}}s dtos, http response status - 200.
- [x] Get {{Author}}s – возвращает список всех {{author}}s, dtos http response status - 200.
- [x] Get {{Tag}}s – возвращает список всех {{tag}}s dtos,  http response status - 200.
- [x] Get {{Comment}}s – возвращает список всех {{comment}}s dtos, http response status - 200.

- [x] Get {{News}} по id – возвращает {{news}} по предоставленному id, http response status - 200.
- [x] Get {{Author}} по id – возвращает {{author}} по предоставленному id, http response status - 200.
- [x] Get {{Tag}} по id – возвращает {{tag}} по предоставленному id, http response status - 200.
- [x] Get {{Comment}} по id – возвращает {{comment}} по предоставленному id, http response status - 200.

- [x] Update {{News}} – обновление полей {{news}} по предоставленному id и возврат обновленного {{news}} в виде dto, http response status - 200.
- [x] Update {{Author}} – обновление полей {{author}} по предоставленному id и возврат обновленного {{author}} в виде dto, http response status - 200.
- [x] Update {{Tag}} – обновление полей {{tag}} по предоставленному id и возврат обновленного {{tag}} в виде dto, http response status - 200.
- [x] Update {{Comment}} – обновление полей {{comment}} по предоставленному id и возврат обновленного {{comment}} в виде dto, http response status - 200.

- [x] Delete {{News}} – удаление {{news}} по предоставленному id, http response status - 204.
- [x] Delete {{Author}} – удаление {{author}} по предоставленному id, http response status - 204.
- [x] Delete {{Tag}} – удаление {{tag}} по предоставленному id, http response status - 204.
- [x] Delete {{Comment}} – удаление {{comment}} по предоставленному id, http response status - 204.

Ожидается, но не будет тестироваться. При реализации обязательно покрытие своими тестами на 100% кода.

- [x] Get {{Author}} by {{news}} id – возвращает {{author}} как dto по предоставленному {{news}} id, http response status - 200.
- [x] Get {{Tag}}s by {{news}} id – возвращает {{tag}}s as list of dtos по предоставленному {{news}} id, http response status - 200.
- [x] Get {{Comment}}s by {{news}} id – возвращает {{comment}}s as list of dtos по предоставленному {{news}} id, http response status - 200.
- [x] Get {{News}} by {{tag}} {{name}}s, {{tag}} ids, {{author}} {{login}}, {{title}}, {{content}} (все параметры являются необязательными и могут использоваться вместе) – возвращает {{news}} по предоставленному набору параметров, http response status - 200. [optional].

Все возвращаемые и полученные данные должны иметь тип [DTO](https://en.wikipedia.org/wiki/Data_transfer_object).

Сопоставление между dto и моделью (объектом домена) должно выполняться на уровне сервиса с использованием любой библиотеки.
Примеры: [Mapstruct](https://mapstruct.org/), [Modelmapper](http://modelmapper.org/).

#### Валидация

Все входные параметры (запросы) должны проверяться непосредственно в коде бизнес-логики с помощью специальной проверки или функций используемого фреймворка.
>Примечание. Для поддержки ваших пользовательских аннотаций и выполнения проверки вне кода бизнес-логики вы можете использовать специализированные решения,
>например: [Aspects](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop).

#### Тестирование

- [x] Покройте слой контроллера  СВОИМИ тестами JUnit, используя, например: [RestAssured Framework](https://semaphoreci.com/community/tutorials/testing-rest-endpoints-using-rest-assured).

#### Обязательные требования:

1. Код должен быть чистым и не должен содержать никаких конструкций, предназначенных исключительно для разработчиков.
2. Приложение должно быть спроектировано и написано с учетом принципов ООП, SOLID и лучших практик проектирования REST.
3. Должна использоваться четкая многоуровневая структура с определением обязанностей каждого прикладного уровня.
4. Вся бизнес-логика должна быть написана в сервисах: отображение `model` в `dto` и наоборот, валидация и т.д.
5. Модуль-web должен принимать и возвращать объекты передачи данных dto.
6. Методы контроллера, возвращающие коллекцию dto, должны будут поддерживать нумерацию страниц и сортировку в будущих версиях.
7. Контроллеры и их методы должны поддерживать управление версиями.
8. Должна быть реализована удобная обработка ошибок: все ошибки должны быть осмысленными и понятными. 
9. Ошибки должны содержать `errorMessage` и `errorCode`, где `errorCode` — ваш пятизначный код, в котором первые три цифры код совпадают с кодом ответа в заголовке HTTP а две оставшиеся имеют произвольные значения, но логически связанны с errorMessage.
10. Приложение должно быть протестировано и пройти все наборы тестов.

#### Рекомендации к приложению:

1. JDK 21 - ожидаемая среда выполнения.
2. Maven. Пока архитектура произвольная, но в итоге мы получим многомодульный проект на базе Spring Boot.
3. Язык программирования: Java

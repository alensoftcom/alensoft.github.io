#  Task110. O-complexity

## Задание: Наибольшая возрастающая подпоследовательность

**Описание:**

Напишите программу на Java, которая находит длину наибольшей возрастающей подпоследовательности (НВП) в заданном массиве целых чисел.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` НВП будет `[-1, 0, 2, 3]`, а её длина равна 4.

**Требования:**

* Программа должна быть реализована в виде класса `LongestIncreasingSubsequence`.
* Класс должен содержать метод `public static int findLISLength(int[] array)`, который принимает на вход массив целых чисел и возвращает длину НВП.
* Реализуйте алгоритм с временной сложностью O(n log n), где n - длина массива.

**Решение:**

```java
import java.util.Arrays;

public class LongestIncreasingSubsequence {

    public static int findLISLength(int[] array) {
        if (array == null || array.length == 0) {
            return 0;
        }

        int[] tails = new int[array.length];
        int size = 0;

        for (int x : array) {
            int i = 0, j = size;
            while (i != j) {
                int m = (i + j) / 2;
                if (tails[m] < x) {
                    i = m + 1;
                } else {
                    j = m;
                }
            }
            tails[i] = x;
            if (i == size) {
                size++;
            }
        }

        return size;
    }

    public static void main(String[] args) {
        int[] array = {3, 4, -1, 0, 6, 2, 3};
        System.out.println("Длина НВП: " + findLISLength(array)); // Вывод: 4
    }
}
```

**Тесты:**

```java
import org.junit.Test;
import static org.junit.Assert.*;

public class LongestIncreasingSubsequenceTest {

    @Test
    public void testEmptyArray() {
        int[] array = {};
        assertEquals(0, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testSingleElementArray() {
        int[] array = {5};
        assertEquals(1, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testIncreasingArray() {
        int[] array = {1, 2, 3, 4, 5};
        assertEquals(5, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testDecreasingArray() {
        int[] array = {5, 4, 3, 2, 1};
        assertEquals(1, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testRandomArray() {
        int[] array = {3, 4, -1, 0, 6, 2, 3};
        assertEquals(4, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testDuplicateElements() {
        int[] array = {2, 2, 2, 2, 2};
        assertEquals(1, LongestIncreasingSubsequence.findLISLength(array));
    }

    @Test
    public void testNegativeNumbers() {
        int[] array = {-2, -1, -3, -5, -4};
        assertEquals(2, LongestIncreasingSubsequence.findLISLength(array));
    }
}
```

**Описание решения:**

Алгоритм использует массив `tails`, где `tails[i]` хранит минимальное значение последнего элемента возрастающей подпоследовательности длины `i+1`. Для каждого элемента `x` из входного массива выполняется бинарный поиск по массиву `tails`, чтобы найти наименьший элемент, который больше или равен `x`. Если такой элемент найден, он заменяется на `x`. В противном случае `x` добавляется в конец массива `tails`, увеличивая длину НВП.

**Тесты:**

Тесты охватывают различные сценарии:

* Пустой массив.
* Массив с одним элементом.
* Возрастающий массив.
* Убывающий массив.
* Массив с произвольными числами.
* Массив с повторяющимися элементами.
* Массив с отрицательными числами.

## Теория: Наибольшая возрастающая подпоследовательность (НВП)

### Введение

Наибольшая возрастающая подпоследовательность (НВП) является классической задачей в области алгоритмов и динамического программирования. Задача заключается в нахождении длины самой длинной подпоследовательности элементов массива, которая является строго возрастающей.

### Определение

**Подпоследовательность** — это последовательность, которая может быть получена из исходной последовательности путем удаления некоторых элементов без изменения порядка оставшихся элементов.

**Возрастающая подпоследовательность** — это подпоследовательность, в которой каждый элемент больше предыдущего.

**Наибольшая возрастающая подпоследовательность (НВП)** — это возрастающая подпоследовательность максимальной длины.

### Пример

Рассмотрим массив `[3, 4, -1, 0, 6, 2, 3]`. НВП в этом массиве будет `[-1, 0, 2, 3]`, а её длина равна 4.

### Алгоритмы решения

Существует несколько подходов к решению задачи НВП:

1. **Динамическое программирование (O(n^2))**:
    - Создаем массив `dp`, где `dp[i]` хранит длину НВП, заканчивающейся на элементе `array[i]`.
    - Инициализируем `dp[i] = 1` для всех `i`, так как минимальная длина НВП равна 1 (сам элемент).
    - Для каждого элемента `array[i]` проверяем все предыдущие элементы `array[j]` (где `j < i`) и обновляем `dp[i]` если `array[j] < array[i]`.
    - Результат будет максимальным значением в массиве `dp`.

2. **Динамическое программирование с бинарным поиском (O(n log n))**:
    - Используем массив `tails`, где `tails[i]` хранит минимальное значение последнего элемента возрастающей подпоследовательности длины `i+1`.
    - Для каждого элемента `x` из входного массива выполняем бинарный поиск по массиву `tails`, чтобы найти наименьший элемент, который больше или равен `x`.
    - Если такой элемент найден, он заменяется на `x`. В противном случае `x` добавляется в конец массива `tails`, увеличивая длину НВП.

### Реализация на Java

```java
import java.util.Arrays;

public class LongestIncreasingSubsequence {

    public static int findLISLength(int[] array) {
        if (array == null || array.length == 0) {
            return 0;
        }

        int[] tails = new int[array.length];
        int size = 0;

        for (int x : array) {
            int i = 0, j = size;
            while (i != j) {
                int m = (i + j) / 2;
                if (tails[m] < x) {
                    i = m + 1;
                } else {
                    j = m;
                }
            }
            tails[i] = x;
            if (i == size) {
                size++;
            }
        }

        return size;
    }

    public static void main(String[] args) {
        int[] array = {3, 4, -1, 0, 6, 2, 3};
        System.out.println("Длина НВП: " + findLISLength(array)); // Вывод: 4
    }
}
```

### Анализ сложности

- **Временная сложность**:
    - Алгоритм с использованием динамического программирования имеет сложность O(n^2).
    - Алгоритм с использованием динамического программирования и бинарного поиска имеет сложность O(n log n).

- **Пространственная сложность**:
    - Оба алгоритма используют дополнительную память O(n).

### Применение

Задача НВП имеет множество практических применений, включая:

- **Анализ временных рядов**: Поиск трендов в данных.
- **Биоинформатика**: Анализ последовательностей ДНК и белков.
- **Теория управления**: Оптимизация последовательности действий.

### Заключение

Наибольшая возрастающая подпоследовательность — это фундаментальная задача в области алгоритмов и динамического программирования. Знание различных подходов к её решению, включая оптимизированные алгоритмы с использованием бинарного поиска, является важным навыком для специалистов по программированию.

## Задания на тему "Наибольшая возрастающая подпоследовательность" (НВП)

### Задание 1: НВП с ограничением на разность

**Описание:**

Дан массив целых чисел и целое число `k`. Найдите длину наибольшей возрастающей подпоследовательности, в которой разность между любыми двумя соседними элементами не превышает `k`.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `k = 2`, НВП будет `[3, 4, 6]`, а её длина равна 3.

### Задание 2: НВП с минимальной суммой

**Описание:**

Дан массив целых чисел. Найдите длину наибольшей возрастающей подпоследовательности с минимальной суммой.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]`, НВП с минимальной суммой будет `[-1, 0, 2, 3]`, а её длина равна 4.

### Задание 3: НВП в двумерном массиве

**Описание:**

Дан двумерный массив целых чисел. Найдите длину наибольшей возрастающей подпоследовательности, если разрешено двигаться только вправо или вниз.

**Пример:**

Для массива:
```
[
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]
]
```
НВП будет `[1, 2, 3, 6, 9]`, а её длина равна 5.

### Задание 4: НВП с перестановками

**Описание:**

Дан массив целых чисел. Найдите длину наибольшей возрастающей подпоследовательности, которую можно получить перестановкой элементов исходного массива.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]`, НВП с перестановками будет `[-1, 0, 2, 3, 4, 6]`, а её длина равна 6.

### Задание 5: НВП с удалением элементов

**Описание:**

Дан массив целых чисел и целое число `k`. Найдите длину наибольшей возрастающей подпоследовательности, которую можно получить удалением не более `k` элементов из исходного массива.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `k = 1`, НВП будет `[-1, 0, 2, 3]`, а её длина равна 4.

### Задание 6: НВП с повторяющимися элементами

**Описание:**

Дан массив целых чисел, в котором могут быть повторяющиеся элементы. Найдите длину наибольшей возрастающей подпоследовательности, в которой каждый элемент может встречаться не более одного раза.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]`, НВП будет `[-1, 0, 2, 3, 4, 6]`, а её длина равна 6.

### Задание 7: НВП с ограничением на количество элементов

**Описание:**

Дан массив целых чисел и целое число `m`. Найдите длину наибольшей возрастающей подпоследовательности, в которой количество элементов не превышает `m`.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `m = 4`, НВП будет `[-1, 0, 2, 3]`, а её длина равна 4.

### Задание 8: НВП с ограничением на сумму

**Описание:**

Дан массив целых чисел и целое число `S`. Найдите длину наибольшей возрастающей подпоследовательности, сумма элементов которой не превышает `S`.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `S = 10`, НВП будет `[-1, 0, 2, 3]`, а её длина равна 4.

### Задание 9: НВП с ограничением на количество различных элементов

**Описание:**

Дан массив целых чисел и целое число `d`. Найдите длину наибольшей возрастающей подпоследовательности, в которой количество различных элементов не превышает `d`.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `d = 3`, НВП будет `[-1, 0, 2]`, а её длина равна 3.

### Задание 10: НВП с ограничением на количество переходов через ноль

**Описание:**

Дан массив целых чисел и целое число `z`. Найдите длину наибольшей возрастающей подпоследовательности, в которой количество переходов через ноль (от отрицательного к положительному или наоборот) не превышает `z`.

**Пример:**

Для массива `[3, 4, -1, 0, 6, 2, 3]` и `z = 1`, НВП будет `[-1, 0, 2, 3]`, а её длина равна 4.

---

Эти задания требуют глубокого понимания алгоритмов и динамического программирования, а также умения адаптировать известные решения под новые условия.


## Доказательство скорости обработки алгоритма НВП с использованием бинарного поиска

### Введение

Алгоритм нахождения наибольшей возрастающей подпоследовательности (НВП) с использованием бинарного поиска имеет временную сложность $ O(n \log n) $, где $ n $ — длина входного массива. В этом доказательстве мы рассмотрим, как достигается такая эффективность.

### Описание алгоритма

Алгоритм использует массив `tails`, где `tails[i]` хранит минимальное значение последнего элемента возрастающей подпоследовательности длины $ i+1 $. Для каждого элемента `x` из входного массива выполняется бинарный поиск по массиву `tails`, чтобы найти наименьший элемент, который больше или равен `x`. Если такой элемент найден, он заменяется на `x`. В противном случае `x` добавляется в конец массива `tails`, увеличивая длину НВП.

### Анализ сложности

1. **Инициализация массива `tails`**:
- Инициализация массива `tails` занимает $ O(n) $ времени, так как мы просто создаем массив размером $ n $.

2. **Проход по входному массиву**:
- Мы проходим по каждому элементу входного массива один раз, что занимает $ O(n) $ времени.

3. **Бинарный поиск**:
- Для каждого элемента `x` мы выполняем бинарный поиск в массиве `tails`. Бинарный поиск имеет временную сложность $ O(\log k) $, где $ k $ — текущая длина массива `tails`.
- В худшем случае, длина массива `tails` может достигать $ n $, поэтому бинарный поиск будет выполняться за $ O(\log n) $ времени.

4. **Обновление массива `tails`**:
- Обновление массива `tails` после каждого бинарного поиска занимает $ O(1) $ времени.

### Суммарная сложность

Таким образом, суммарная временная сложность алгоритма составляет:

$$
O(n) + O(n \cdot \log n) + O(n) = O(n \log n)
$$

- $ O(n) $ — инициализация массива `tails`.
- $ O(n \cdot \log n) $ — проход по входному массиву и выполнение бинарного поиска для каждого элемента.
- $ O(n) $ — обновление массива `tails`.

### Заключение

Алгоритм нахождения НВП с использованием бинарного поиска имеет временную сложность $ O(n \log n) $, что делает его эффективным для больших входных данных. Это достигается за счет использования бинарного поиска для обновления массива `tails`, что позволяет сократить время поиска места для вставки нового элемента.
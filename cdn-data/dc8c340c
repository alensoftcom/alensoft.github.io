# REST Basics - Spring Web

## Материалы

- Основы RESTful API
- Модель зрелости API REST Ричардсона
- Некоторые определения, связанные с REST API
- Архитектурные ограничения REST
- Основные принципы проектирования REST API

## Основы RESTful API

_**REST is an API architecture style.**_ Это сокращение от Representational State Transfer (REST). REST — это архитектурный стиль, который определяет набор ограничений, используемых для создания веб-сервисов. REST API — это способ доступа к веб-сервисам простым и гибким способом без какой-либо обработки. Технология REST обычно предпочтительнее более надежной технологии Simple Object Access Protocol (SOAP), поскольку REST использует меньшую полосу пропускания, является простой и гибкой, что делает ее более подходящей для использования в Интернете. Она используется для извлечения или предоставления некоторой информации из веб-сервиса. Все коммуникации, осуществляемые через REST API, используют только протокол HTTP.

## Модель зрелости API REST Ричардсона

Модель зрелости Ричардсона оценивает RESTful API по степени зрелости. Модель зрелости REST — это способ оценить ваш API в соответствии с ограничениями REST. Она описывает четыре различных уровня REST (начиная с 0-го по 3-й уровень). REST API, поддерживающий элементы управления гипермедиа, классифицируется как Уровень 3 в этой модели зрелости.

- **Level 0 - a single URI and use a single HTTP method (typically POST)**  
    Эти сервисы имеют один URI и используют один метод HTTP (обычно POST). Это самый примитивный способ создания приложений SOA с одним методом POST и использованием XML для связи между сервисами. Нулевой уровень зрелости не использует ни один из URI, методов HTTP и возможностей HATEOAS.
    
- **Level 1 - different URIs for different resources but use a single HTTP method (typically POST)**  
    Проектирование API на уровне 1 заключается в использовании различных URI для взаимодействия с различными ресурсами в вашем приложении, но только одного HTTP-глагола – обычно HTTP POST. Эти сервисы дадут каждому ресурсу, доступному в приложении, уникальный URI. Уникальный URI отдельно идентифицирует один уникальный ресурс – и это делает эти REST API лучше, чем нулевой уровень.
    
- **Level 2 - different URIs and HTTP Verbs for manipulating resources**  
    REST API уровня 2 использует различные URI и HTTP-методы, но не использует HATEOAS. Такой REST API поддерживает несколько HTTP-глаголов на каждом открытом ресурсе — операции Create, Read, Update и Delete (CRUD). Здесь состояние ресурсов, обычно представляющих бизнес-сущности, можно изменять по сети. Уровень зрелости 2 — наиболее популярный вариант использования принципов REST, которые рекомендуют использовать различные глаголы на основе методов HTTP-запросов, в то время как система может иметь несколько ресурсов.
    
- **Level 3 - different URIs and HTTP Verbs and HATEOAS**  
    REST API уровня 3 — это наиболее зрелый уровень модели Ричардсона, который способствует легкой обнаруживаемости. Этот уровень позволяет ответам быть самоописательными с помощью HATEOAS. Уровень 3 проводит потребителей услуг через путь ресурсов, вызывая в результате переходы состояний приложения.
    

## Некоторые определения, связанные с REST API

- _**Resource**_  
    Ключевой абстракцией информации в REST является ресурс. Любая информация, которая может быть названа, может быть ресурсом: документ или изображение, временная служба (например, «сегодняшняя погода в Лос-Анджелесе»), набор других ресурсов, невиртуальный объект (например, человек) и т. д. Другими словами, любое понятие, которое может быть идентифицировано URI, предоставленным сервером, может быть названо ресурсом. Ресурс — это объект с типом, связанными данными, отношениями с другими ресурсами и набором методов, которые работают с ним. Он похож на экземпляр объекта в объектно-ориентированном программировании, с важным отличием, что для ресурса определено только несколько стандартных методов (соответствующих стандартным методам HTTP GET, POST, PUT и DELETE), в то время как экземпляр объекта обычно имеет много методов. Ресурсы могут быть одиночными или сгруппированными в коллекции.  
    _**1.Singleton and Collection Resources**_  
    Например, _«клиенты»_ — это ресурс коллекции, а _«клиент»_ — это единичный ресурс (в банковском домене). Мы можем идентифицировать ресурс коллекции _«клиенты»_ с помощью URI **“/customers“**. Мы можем идентифицировать один ресурс _«клиента»_ с помощью URI **“/customers/{customerId}“**.  
    _**2.Collection and Sub-collection Resources**_  
    Ресурс может также содержать ресурсы подколлекции. Например, ресурсы подколлекции _«счета»_ конкретного _«клиента»_ могут быть идентифицированы с помощью URN **“/customers/{customerId}/accounts”** (в банковском домене). Аналогично, единичный ресурс _«счет»_ внутри подколлекции ресурсов _«счета»_ может быть идентифицирован следующим образом: **“/customers/{customerId}/accounts/{accountId}“**.
    
- _**Resource state**_  
    Состояние ресурса — это текущее состояние ресурса на сервере в любой момент времени — и оно не имеет ничего общего с взаимодействием между клиентом и сервером. Это то, что мы получаем в ответ от сервера как ответ API. Мы называем это представлением ресурса.
    
- _**Resource representations**_  
    Сервер может предоставлять различные представления для одного и того же ресурса. Состояние ресурса может быть представлено в нескольких форматах, таких как JSON, XML, YAML и т. д. Клиент может использовать _**content negotiation (Accept ot Content-Type)**_ запрашивать различные представления одного и того же ресурса.
    
- _**Resource identifiers**_  
    API REST используют _**Uniform Resource Identifiers (URIs)**_ для адресации ресурсов. Разработчики REST API должны создавать URI, которые передают модель ресурсов REST API потенциальным клиентам API. Когда ресурсы названы правильно, API интуитивно понятен и прост в использовании. Если сделано плохо, тот же API может быть сложным в использовании и понимании. Создавая URI для ресурсов, вы должны следовать принципам (лучшей практике), описанным ниже в этом документе.
    
- _**Application state**_  
    Состояние приложения — это данные на стороне сервера, которые серверы хранят для идентификации входящих клиентских запросов, их предыдущих деталей взаимодействия и текущей контекстной информации. Важно понимать разницу между состоянием приложения и состоянием ресурса. Это совершенно разные вещи.
    
- _**Stateless**_  
    Отсутствие состояния означает, что каждый HTTP-запрос происходит в полной изоляции. Когда клиент делает HTTP-запрос, он включает в себя всю информацию, необходимую серверу для выполнения запроса. Сервер никогда не полагается на информацию из предыдущих запросов от клиента и не хранит состояние о сеансе клиента на стороне сервера. Если какая-либо такая информация важна, то клиент отправит ее как часть текущего запроса. Отсутствие состояния REST означает свободу от состояния приложения.
    
- _**REST API endpoint**_  
    Конечная точка — это один конец канала связи. Когда API взаимодействует с другой системой, точки соприкосновения этой связи считаются конечными точками. Для API конечная точка может включать URI сервера или службы. Каждая конечная точка — это место, из которого API могут получать доступ к ресурсам, необходимым им для выполнения своей функции. API работают с использованием «запросов» и «ответов». Когда API запрашивает информацию у веб-приложения или веб-сервера, он получает ответ. Место, куда API отправляют запросы и где находится ресурс, называется конечной точкой.
    
- _**Idempotence**_  
    Идемпотентный метод — это метод, который может быть вызван много раз без разных результатов. Не имеет значения, вызывается ли метод один раз или десять раз. ПРИМЕЧАНИЕ: POST не является ни безопасным, ни идемпотентным.  
    Пример:  
    
    ```java
    a = 5; // It is Idempotence, as final value(a = 5) would not change after executing it multiple times.
    
    a++; // It is not Idempotence because the final value will depend upon the number of times the statement is executed.
    
    ```
    
- _**Safety**_  
    Концепции _**‘idempotent methods’**_ и _**‘safe methods’**_ часто путают. Безопасный метод не изменяет возвращаемое значение, он читает – но никогда не записывает. Безопасные методы – это HTTP-методы, которые не изменяют ресурсы. Например, использование GET или HEAD на URI ресурса НИКОГДА не должно изменять ресурс.  
    Пример:  
    
    ```java
    x + 0; //it is idempotent and also safe, as final value x would not change after executing it multiple times.
    
    x = 5; //it is idempotent but is not safe, as original value x could be changed to 5
    
    ```
    
    Первый из них, добавление нуля, будет возвращать одно и то же значение каждый раз (он идемпотентен), а добавление нуля не окажет никакого влияния на это значение (он также безопасен). Второй пример будет возвращать одно и то же значение каждый раз (он идемпотентен), но не безопасен (если x отличается от 5 до выполнения операции, она изменяет x). Таким образом, все безопасные методы идемпотентны, но не все идемпотентные методы безопасны.
    
- _**HTTP PUT vs HTTP PATCH**_  
    Метод запроса HTTP PATCH применяет частичные изменения к ресурсу. Запрос PATCH считается набором инструкций о том, как изменить ресурс. Сравните это с PUT; который является полным представлением ресурса. PATCH не обязательно идемпотентен, хотя может быть. Сравните это с PUT; который всегда идемпотентен. Слово «идемпотентный» означает, что любое количество повторных идентичных запросов оставит ресурс в том же состоянии. Например, если поле счетчика с автоинкрементом является неотъемлемой частью ресурса, то PUT естественным образом перезапишет его (так как он перезаписывает все), но не обязательно так для PATCH. Тело PATCH должно быть не просто измененной частью ресурса, а каким-то языком патчей, например _**JSON Patch**_ или _**XML Patch**_ . PATCH (как и POST) может иметь побочные эффекты для других ресурсов, поэтому он небезопасен.
    
- _**HATEOAS (Hypermedia as the Engine of Application State)**_  
    HATEOAS является ограничением архитектуры приложения REST. HATEOAS сохраняет архитектуру стиля REST уникальной по сравнению с большинством других архитектур сетевых приложений. Термин «гипермедиа» относится к любому контенту, содержащему ссылки на другие формы мультимедиа, такие как изображения, фильмы и текст. Архитектурный стиль REST позволяет нам использовать гипермедиа-ссылки в содержимом ответа API. Он позволяет клиенту динамически переходить к соответствующим ресурсам, проходя по гипермедиа-ссылкам. Навигация по гипермедиа-ссылкам концептуально аналогична просмотру веб-страниц путем нажатия на соответствующие гиперссылки для достижения конечной цели. Например, приведенный ниже ответ JSON может быть получен от API, например HTTP GET _http://api.domain.com/management/departments/10_
    
    ```json
    {
        "departmentId": 10,
        "departmentName": "Administration",
        "locationId": 1700,
        "managerId": 200,
        "links": [
            {
                "href": "10/employees",
                "rel": "employees",
                "action":"GET",
                "types":["text/xml","application/json"]
            }
        ]
    }
    ```
    
    В приведенном выше примере ответ, возвращаемый сервером, содержит гипермедийные ссылки на ресурсы сотрудников _10/сотрудники_ , по которым клиент может перейти, чтобы прочитать сотрудников, принадлежащих отделу. Преимущество указанного выше подхода заключается в том, что гипермедийные ссылки, возвращаемые сервером, управляют состоянием приложения, а не наоборот. JSON не имеет общепринятого формата для представления ссылок между двумя ресурсами. Мы можем выбрать отправку тела ответа или решить отправлять ссылки в заголовках HTTP-ответа.
    

## Архитектурные ограничения REST

### 1. Client-Server

Приложение REST должно иметь архитектуру клиент-сервер. Это ограничение по сути означает, что клиентские приложения и серверные приложения ДОЛЖНЫ иметь возможность развиваться отдельно без какой-либо зависимости друг от друга. Клиент должен знать только URI ресурсов, и это все. Клиент запрашивает ресурсы и не заботится о хранилище данных, которое остается внутренним для каждого сервера, а сервер хранит ресурсы и не заботится о пользовательском интерфейсе или состоянии пользователя. Они могут развиваться независимо. Клиенту не нужно ничего знать о бизнес-логике, а серверу не нужно ничего знать о внешнем пользовательском интерфейсе.

### 2. Uniform Interface

Это ключевое ограничение, которое отличает REST API от не-REST API. Оно предполагает, что должен быть единый способ взаимодействия с данным сервером независимо от устройства или типа приложения (веб-сайт, мобильное приложение). Существует четыре руководящих принципа Единого интерфейса:

- _**Resource-Based:**_ Отдельные ресурсы идентифицируются в запросах. Например: API/пользователи.  
    
- _**Manipulation of Resources Through Representations:**_ Клиент имеет представление ресурса и содержит достаточно информации для изменения или удаления ресурса на сервере, при условии, что у него есть разрешение на это. Пример: Обычно пользователь получает идентификатор пользователя, когда запрашивает список пользователей, а затем использует этот идентификатор для удаления или изменения этого конкретного пользователя.
- _**Self-descriptive Messages:**_ Каждое сообщение содержит достаточно информации для описания того, как обрабатывать сообщение, чтобы сервер мог легко проанализировать запрос.
- _**Hypermedia as the Engine of Application State (HATEOAS):**_ Необходимо включить ссылки для каждого ответа, чтобы клиент мог легко найти другие ресурсы.

### 3. Stateless

Ограничение называется _**Statelessness**_ если сервер не хранит никаких данных о сеансе клиента на стороне сервера. Это означает, что необходимые данные\состояние для обработки запроса содержатся в самом запросе, и сервер не будет хранить ничего, связанного с сеансом клиента. Сервер не будет хранить ничего о последнем HTTP-запросе, сделанном клиентом. Он будет обрабатывать каждый запрос как новый. _**No client context shall be stored on the server between requests. No session, no history. The client is responsible for managing the state of the application**_ . В REST клиент должен включить всю информацию для сервера, чтобы выполнить запрос, будь то как часть параметров запроса, заголовков или URI. Чтобы сделать REST API без сохранения состояния, даже данные аутентификации/авторизации клиента не должны храниться на стороне сервера. Предоставляйте учетные данные аутентификации с каждым запросом. Отсутствие сохранения состояния обеспечивает большую доступность, поскольку серверу не нужно поддерживать, обновлять или сообщать состояние сеанса клиента. Существует недостаток, когда клиенту необходимо отправить слишком много данных на сервер, что снижает объем оптимизации сети и требует большей пропускной способности.

### 4. Cacheable

Для обеспечения лучшей производительности приложения часто делают кэшируемыми. Каждый ответ должен включать информацию о том, кэшируется ли ответ или нет, и на какой срок ответы могут кэшироваться на стороне клиента. Клиент будет возвращать данные из своего кэша для любого последующего запроса, и не будет необходимости снова отправлять запрос на сервер. Хорошо управляемое кэширование частично или полностью устраняет некоторые взаимодействия клиент-сервер, что дополнительно повышает доступность и производительность. Но иногда есть вероятность, что пользователь может получить устаревшие данные. Чтобы предотвратить это, кэшированные данные необходимо обновлять каждый раз, когда данные обновляются на стороне сервера.

### 5. Layered System

Это ограничение говорит о том, что архитектура приложения может быть многоуровневой, не давая клиенту знать об этом. Архитектура приложения должна состоять из нескольких слоев. Каждый слой не знает ничего ни о каком слое, кроме непосредственного слоя, и между клиентом и конечным сервером может быть много промежуточных серверов (слоев). Промежуточные серверы могут улучшить доступность системы, обеспечивая балансировку нагрузки и предоставляя общие кэши.

### 6. Code on demand (optional)

Это необязательная функция. Согласно этому, серверы также могут предоставлять исполняемый код клиенту. Примерами кода по требованию могут быть код рендеринга виджета пользовательского интерфейса или клиентские скрипты, такие как JavaScript/Python.

## Основные принципы проектирования REST API

### 1. Use nouns to represent resources

RESTful URI должен ссылаться на ресурс, который является объектом (существительным), а не ссылаться на действие (глагол), потому что у существительных есть свойства, которых нет у глаголов – аналогично, у ресурсов есть атрибуты. Вот некоторые примеры ресурса:

- Пользователи системы
- Учетные записи пользователей
- Сетевые устройства и т. д., а также их URI ресурсов можно спроектировать следующим образом:

```bash
http://api.example.com/device-management/managed-devices 
http://api.example.com/device-management/managed-devices/{device-id} 
http://api.example.com/user-management/users
http://api.example.com/user-management/users/{id}
```

Ресурсы можно разделить по **resource archetypes** на четыре категории **(document, collection, store, and controller)**. Тогда было бы лучше, если бы вы всегда стремились поместить ресурс в один архетип, а затем последовательно использовать его соглашение об именовании.

- ### document
    
    Ресурс документа — это единичное понятие, родственное экземпляру объекта или записи базы данных. В REST вы можете рассматривать его как один ресурс внутри коллекции ресурсов. Представление состояния документа обычно включает как поля со значениями, так и ссылки на другие связанные ресурсы. Используйте «единичное» имя для обозначения архетипа ресурса документа.
    
    ```bash
    http://api.example.com/device-management/managed-devices/{device-id}
    http://api.example.com/user-management/users/{id}
    http://api.example.com/user-management/users/admin
    ```
    
- ### collection
    
    Ресурс коллекции — это управляемый сервером каталог ресурсов. Клиенты могут предлагать новые ресурсы для добавления в коллекцию. Однако ресурс коллекции решает, создавать новый ресурс или нет. Ресурс коллекции выбирает, что он хочет содержать, а также определяет URI каждого содержащегося ресурса. Используйте имя «множественное число» для обозначения архетипа ресурса коллекции.
    
    ```bash
    http://api.example.com/device-management/managed-devices
    http://api.example.com/user-management/users
    http://api.example.com/user-management/users/{id}/accounts
    ```
    
- ### store
    
    Хранилище — это клиентское хранилище ресурсов. Ресурс хранилища позволяет клиенту API помещать ресурсы, получать их обратно и решать, когда их удалять. Хранилище никогда не генерирует новые URI. Вместо этого каждый сохраненный ресурс имеет URI. URI был выбран клиентом, когда ресурс изначально помещал его в хранилище. Используйте имя «множественное число» для обозначения архетипа ресурса хранилища.
    
    ```bash
    http://api.example.com/song-management/users/{id}/playlists
    ```
    
- ### controller
    
    Ресурс контроллера моделирует процедурную концепцию. Ресурсы контроллера подобны исполняемым функциям с параметрами и возвращаемыми значениями, входами и выходами. _**A REST API relies on controller resources to perform application specific actions that cannot be logically mapped to one of the standard methods (create, retrieve, update and delete).**_ Используйте «глагол» для обозначения архетипа контроллера. «Глагол» контроллера обычно появляется как последний сегмент в пути URI, без дочерних ресурсов, которые следовали бы за ними в иерархии.
    
    ```bash
    http://api.example.com/cart-management/users/{id}/cart/checkout 
    http://api.example.com/song-management/users/{id}/playlist/play
    ```
    
    В приведенном выше примере показан ресурс контроллера, который позволяет клиенту оформить заказ в корзине или начать воспроизведение плейлиста клиента.
    

### 2. Use consistent resource naming conventions and URI formatting

Использование согласованных соглашений об именовании ресурсов и форматирования URI позволяет минимизировать неоднозначность и максимизировать читаемость и удобство обслуживания. Ниже приведены некоторые советы по дизайну для достижения согласованности:

- **Use forward slash (/) to indicate hierarchical relationships**  
    Символ косой черты (/) используется в части пути URI для указания иерархической связи между ресурсами. Например:
    
    ```bash
    http://api.example.com/device-management
    http://api.example.com/device-management/managed-devices
    http://api.example.com/device-management/managed-devices/{id}
    http://api.example.com/device-management/managed-devices/{id}/scripts
    http://api.example.com/device-management/managed-devices/{id}/scripts/{id}
    ```
    
- **Do not use trailing forward slash (/) in URIs**  
    Как последний символ в пути URI, косая черта (/) не добавляет семантического значения и может сбивать с толку. Лучше убрать ее из URI.  
    Примеры:  
    
    ```cpp
    http://api.example.com/device-management/managed-devices/ 
    http://api.example.com/device-management/managed-devices  /*This is much better version*/
    ```
    
- **Use hyphens (-) to improve the readability of URIs**  
    Чтобы сделать ваши URI простыми для сканирования и интерпретации, используйте символ дефиса (-) для улучшения читаемости имен в длинных сегментах пути.  
    Примеры:  
    
    ```cpp
    http://api.example.com/devicemanagement/manageddevices/
    http://api.example.com/device-management/managed-devices  /*This is much better version*/
    ```
    
- **Do not use underscores ( _ )**  
    Можно использовать подчеркивание вместо дефиса, чтобы использовать его в качестве разделителя – Но в зависимости от шрифта приложения, возможно, что символ _подчеркивания (_ )_ _может быть либо частично скрыт, либо полностью скрыт в некоторых браузерах или экранах._ Чтобы избежать этой путаницы, используйте дефисы (-) вместо подчеркивания ( _  
    Примеры:  
    
    ```bash
    http://api.example.com/inventory-management/managed-entities/{id}/install-script-location  //More readable
    http://api.example.com/inventory_management/managed-entities/{id}/install_script_location  //(_) may be obscured or hidden in some browsers or screens
    http://api.example.com/inventory-management/managedEntities/{id}/installScriptLocation     //Less readable
    ```
    
- **Use lowercase letters in URIs**  
    Если это удобно, в путях URI следует отдавать предпочтение строчным буквам.  
    Примеры:  
    
    ```perl
    http://api.example.org/my-folder/my-doc     //1
    HTTP://API.EXAMPLE.ORG/my-folder/my-doc     //2
    http://api.example.org/My-Folder/my-doc     //3
    ```
    
    В приведенных выше примерах 1 и 2 одинаковы, а 3 — нет, поскольку в нем слово My-Folder написано заглавными буквами.
    
- **Do not use file extensions**  
    Расширения файлов выглядят плохо и не добавляют никаких преимуществ. Их удаление также уменьшает длину URI. Нет причин их сохранять. Помимо вышеуказанной причины, если вы хотите выделить тип носителя API с помощью расширения файла, то вы должны полагаться на тип носителя, как сообщается через заголовок Content-Type, чтобы определить, как обрабатывать содержимое тела.  
    Примеры:  
    
    ```perl
    http://api.example.com/device-management/managed-devices.xml  /*Do not use xml in the URI*/
    http://api.example.com/device-management/managed-devices 	    /*This is correct URI*/
    ```
    
- **Never use CRUD function names in**  
    Мы не должны использовать URI для указания функции CRUD. URI должны использоваться только для уникальной идентификации ресурсов, а не для каких-либо действий над ними. Мы должны использовать методы HTTP-запросов для указания того, какая функция CRUD выполняется.  
    Примеры:  
    
    ```bash
    HTTP GET http://api.example.com/device-management/managed-devices           //Get all devices
    HTTP POST http://api.example.com/device-management/managed-devices          //Create new Device
    HTTP GET http://api.example.com/device-management/managed-devices/{id}      //Get device for given Id
    HTTP PUT http://api.example.com/device-management/managed-devices/{id}      //Update device for given Id
    HTTP DELETE http://api.example.com/device-management/managed-devices/{id}   //Delete device for given Id
    ```
    
- **Use query component to filter URI collection**  
    Часто вы будете сталкиваться с требованиями, когда вам понадобится коллекция ресурсов, отсортированная, отфильтрованная или ограниченная на основе определенного атрибута ресурса. Для этого требования не создавайте новые API — вместо этого включите возможности сортировки, фильтрации и разбиения на страницы в API коллекции ресурсов и передайте входные параметры как параметры запроса.  
    Примеры:  
    
    ```bash
    http://api.example.com/device-management/managed-devices
    http://api.example.com/device-management/managed-devices?region=USA
    http://api.example.com/device-management/managed-devices?region=USA&brand=XYZ
    http://api.example.com/device-management/managed-devices?region=USA&brand=XYZ&sort=installation-date
    ```
    
- **Consistent subdomain names should be used for your APIs**  
    Домен верхнего уровня и первые имена поддоменов (например, soccer.restapi.org) API должны идентифицировать владельца сервиса. Полное доменное имя API должно добавлять поддомен с именем api.  
    Например:
    
    ```bash
    http://api.soccer.restapi.org
    ```
    
- **Consistent subdomain names should be used for your client developer portal**  
    Многие REST API имеют связанный веб-сайт, известный как портал разработчика.  
    Например:
    
    ```bash
    http://developer.soccer.restapi.org
    ```
    

### 3. Define API operations in terms of HTTP methods and HTTP response status codes

HTTP определил несколько наборов методов, которые указывают тип действия, которое должно быть выполнено с ресурсами. _URI — это предложение, где ресурсы — это существительные, а методы HTTP — это глаголы._ В таблице ниже суммировано использование наиболее часто используемых методов HTTP и кодов статуса ответа HTTP.

#### Метод -> CRUD -> Ресурс коллекции (например, /users) | Одиночный ресурс (например, /users/123) |

- **POST** -> Create -> **201 (Created)**, заголовок «Location» со ссылкой на /users/{id}, содержащий новый идентификатор;
    
    **400 (Bad Request)**, если сервер не может разобрать тело запроса (причина ошибок разработки);
    
    **409 (Conflict)**, если запрос конфликтует с текущим состоянием целевого ресурса;
    
    **422 (Unprocessable Entity)**, если сервер не может обработать данные запроса из-за ошибок проверки, вызванных конечным клиентом из-за отправки недопустимых полей. | Избегайте использования POST на одном ресурсе |
    
- **GET** -> Read -> **200 (OK)**, список пользователей. Используйте пагинацию, сортировку и фильтрацию для навигации по большим спискам;  
    
    **403 (Forbidden)**, если пользователь аутентифицирован, но ему не разрешен доступ к ресурсу;
    
    **404 (Not Found)** если ресурсы не найдены. | **200 (OK)**, однопользовательский.  
    
    **404 (Not Found)** если ресурс не найден или неверный идентификатор |
    
- **PUT** -> Update/Replace -> **405 (Method not allowed)**, если только вы не хотите обновить каждый ресурс во всей коллекции ресурсов | **200 (OK)** если ответ включает обновленную сущность;  
    
    **400 (Bad Request)**, если сервер не может разобрать тело запроса (причина ошибок разработки);
    
    **403 (Forbidden)**, если пользователь аутентифицирован, но ему не разрешен доступ к ресурсу;  
    
    **404 (Not Found)** если ресурс не найден или недействительный идентификатор;  
    
    **409 (Conflict)**, если есть конфликт запроса с текущим состоянием целевого ресурса; || **200 (OK)** если ответ включает сущность, описывающую статус;
    
    **422 (Unprocessable Entity)**, если сервер не может обработать данные запроса из-за ошибок проверки, вызванных конечным клиентом из-за отправки недопустимых полей.
    
- **DELETE** -> Delete -> **405 (Method not allowed)**, если вы не хотите удалить всю коллекцию — используйте с осторожностью | **200 (OK)**, если ответ включает сущность, описывающую статус;
    
    **202 (Accepted)**, если действие поставлено в очередь;
    
    **204 (No Content)**, если действие было выполнено, но ответ не включает в себя сущность;
    
    **404 (Not Found)**, если ресурс не найден или имеет недействительный идентификатор.
    
    _Повторный вызов API DELETE для этого ресурса не изменит результат, однако повторный вызов DELETE для ресурса вернет **404 (NOT FOUND)** так как он уже был удален._ |
    

### 4. Allow filtering, sorting, pagination and searching

Сложные фильтры результатов, требования сортировки, разбиение данных на страницы и расширенный поиск (при ограничении одним типом ресурса) можно легко реализовать в виде параметров запроса поверх базового URI.

- **Filtering:** Используйте уникальный параметр запроса для каждого поля, реализующего фильтрацию. Например, при запросе списка билетов из **/tickets** конечная точка, вы можете ограничить их только теми, которые находятся в открытом состоянии. Это можно сделать с помощью запроса типа
    
    ```perl
    GET /tickets?state=open
    ```
    
    Где, **state** параметр запроса, реализующий фильтр.
    
- **Sorting:** Подобно фильтрации, сортировка общего параметра может использоваться для описания правил сортировки. Приспособьте сложные требования сортировки, позволив параметру сортировки принимать список полей, разделенных запятыми, каждое из которых может иметь унарный отрицательный знак, чтобы подразумевать сортировку по убыванию. Давайте рассмотрим несколько примеров:
    
    ```sql
    GET /tickets?sort=-priority  //retrieves a list of tickets in descending order of priority
    GET /tickets?sort=-priority,createdAt  //retrieves a list of tickets in descending order of priority. 
                                           //within a specific priority, older tickets are ordered first
    GET /users?sort=email&order=asc //sort by email in asc order
    GET /users?sort=email.asc //sort by email in asc order
    ```
    
- **Pagination:** Если набор данных слишком большой, мы делим его на более мелкие части, что помогает повысить производительность и облегчает обработку ответа. Использование Limit/Offset — это простейшая форма разбиения на страницы. Limit/Offset стал популярен в приложениях, использующих базы данных SQL, в которых уже есть LIMIT и OFFSET как часть синтаксиса SQL SELECT.  
    Пример:
    
    ```bash
    GET /companies?limit=20 //get the list of first 20 companies
    GET /companies?limit=20&offset=20 //get next 20 companies
    GET /companies?limit=20&after_id=20 //get 20 companies after the id of ‘20’
    GET /companies?limit=20&after_id=20&sort_by=name //get 20 companies after the id of ‘20’ sorting by company name
    GET /companies?page=23 //get the list of companies on 23rd page.
    ```
    
- **Searching:** Иногда базовых фильтров недостаточно, и вам нужна мощь полнотекстового поиска. Возможно, вы уже используете ElasticSearch или другую технологию поиска на основе Lucene. Когда полнотекстовый поиск используется как механизм извлечения экземпляров ресурсов для определенного типа ресурса, он может быть представлен в API как параметр запроса на конечной точке ресурса. Допустим, поисковые запросы должны передаваться напрямую в поисковую систему, а вывод API должен быть в том же формате, что и обычный результат списка. Объединяя их вместе, мы можем создавать запросы, подобные:
    
    ```bash
    GET /tickets?sort=-updatedAt  //Retrieve recently updated tickets
    GET /tickets?state=closed&sort=-updatedAt  //Retrieve recently closed tickets
    GET /tickets?q=return&state=open&sort=-priority,createdAt  //Retrieve the highest priority open tickets 
                                                               //mentioning the word 'return'
    ```
    
    Вы можете использовать более сложные запросы для поиска ресурсов, например, добавление диапазона, условные выражения для поиска, например:
    
    ```cpp
    GET /items?price[gte]=10&price[lte]=100 //find all the items where the price is 
                                            //greater than or equal to 10, but less than or equal to 100.
    ```
    
    У нас может быть столько операторов, сколько необходимо, например: **[lte], [gte], [exists], [regex], [before], and [after]**Скобки немного сложнее анализировать на стороне сервера, но они обеспечивают большую гибкость в том, что такое значение фильтра для клиентов. Нет необходимости обрабатывать специальные символы по-разному. Подобно подходу со скобками, вы можете разработать API для получения оператора с использованием символа двоеточия **:**.  
    Например:
    
    ```cpp
    GET /items?price=gte:10&price=lte:100 //find all the items where the price is greater than 
                                          //or equal to 10, but less than or equal to 100.
    ```
    
    Вы можете объединить два подхода (используя скобки и двоеточие) для поиска ресурсов.  
    Пример:
    
    ```cpp
    GET /items?q=title:red chair AND price:[10 TO 100] //search items for those that contain the terms red chair   
                                                       //and the price is greater than or equal to 10 and  less than or equal to 100
    ```
    
    Если добавление большого количества параметров запроса в методы GET делает URI слишком длинным, сервер может ответить статусом HTTP 414 URI Too long. Чтобы избежать проблем, вы можете хранить часто используемые запросы на стороне сервера и передавать только псевдоним запроса в качестве параметра или части пути.
    
- **Use aliases for common queries:** Чтобы сделать опыт API более приятным для обычного потребителя, рассмотрите возможность упаковки наборов условий в легкодоступные пути RESTful. Например, недавно закрытый запрос тикетов выше можно упаковать как
    
    ```bash
    GET /tickets/recently_closed //query alias in the path
    GET /tickets/?queryAlias=recently_closed //query alias as a parameter 
    ```
    
    Где recently_closed — это псевдоним для набора параметров запроса, хранящегося на стороне сервера.
    
- **Limiting which fields are returned by the API:** Потребителю API не всегда нужно полное представление ресурса. Возможность выбирать и выбирать возвращаемые поля имеет большое значение для того, чтобы потребитель API минимизировал сетевой трафик и ускорил собственное использование API. Используйте параметр запроса полей, который принимает разделенный запятыми список полей для включения. Например, следующий запрос извлечет ровно столько информации, сколько нужно для отображения отсортированного списка открытых тикетов:
    
    ```bash
    GET /tickets?fields=id,subject,updated_at&state=open&sort=-updated_at
    ```
    
    **Note:** Этот подход также можно комбинировать с автозагрузкой связанных ресурсов, см. ниже:
    
    ```bash
    GET /tickets?embed=customer&fields=id,customer.id,customer.name
    ```
    
- **Autoloading related resource representations:** Существует много случаев, когда потребителю API необходимо загрузить данные, связанные с запрашиваемым ресурсом (или на которые ссылается ресурс). Вместо того, чтобы требовать от потребителя многократного обращения к API для получения этой информации, можно было бы получить значительный выигрыш в эффективности, разрешив возвращать и загружать связанные данные вместе с исходным ресурсом по требованию. Однако, поскольку это противоречит некоторым принципам RESTful, вы можете минимизировать это отклонение, делая это только на основе параметра запроса embed (или expand). В этом случае embed будет разделенным запятыми списком полей для встраивания. Для ссылки на подполя можно использовать точечную нотацию.  
    Например:
    
    ```bash
    GET /tickets/12?embed=customer.name,assigned_user
    ```
    
    Это вернет тикет с дополнительными встроенными данными, например:
    
    ```json
    {
      "id" : 12,
      "subject" : "I have a question!",
      "summary" : "Hi, ....",
      "customer" : {
        "name" : "Bob"
      },
      "assigned_user": {
       "id" : 42,
       "name" : "Jim"
      }
    }
    ```
    
    Конечно, способность реализовать что-то подобное действительно зависит от внутренней сложности. Такого рода внедрение может легко привести к **N+1 select issue**.
    

### 5. Handle errors gracefully and return standard error codes

Чтобы исключить путаницу для пользователей API при возникновении ошибки, мы должны изящно обрабатывать ошибки и возвращать коды ответа HTTP, которые указывают, какой тип ошибки произошел. Это дает разработчикам API достаточно информации, чтобы понять возникшую проблему. Мы не хотим, чтобы ошибки приводили к падению нашей системы, поэтому мы можем оставить их необработанными, что означает, что потребитель API должен их обработать. API всегда должен возвращать разумные коды статуса HTTP. Ошибки API обычно делятся на 2 типа: **400 series status codes for client issues** & **500 series status codes for server issues**.  
Распространенные коды статуса HTTP-ошибок включают в себя:

- **400 Bad Request** – Это означает, что сервер не может проанализировать тело запроса (причина ошибок разработки). Например: Отправка недопустимого JSON приведет к ответу 400 Bad Request. Отправка неправильного типа значений JSON приведет к ответу 400 Bad Request.
- **401 Unauthorized** – Это означает, что пользователь не авторизован для доступа к ресурсу. Обычно возвращается, когда пользователь не аутентифицирован.
- **403 Forbidden** – Это означает, что пользователь аутентифицирован, но ему не разрешен доступ к ресурсу.
- **404 Not Found** – Это означает, что ресурс не найден.
- **406 Not Acceptable** – Это означает, что сервер не может выдать ответ, соответствующий списку приемлемых значений, определенных в заголовках упреждающего согласования содержимого запроса, и что сервер не желает предоставлять представление по умолчанию.
- **409 Conflict** – Это указывает на конфликт запроса с текущим состоянием целевого ресурса. Конфликты чаще всего возникают в ответ на запрос PUT или POST при нарушении ограничений ресурса.
- **422 Unprocessable Entity** – Это означает, что сервер понимает тип содержимого сущности запроса, и синтаксис сущности запроса правильный, но он не смог обработать содержащиеся инструкции. Код состояния довольно часто используется для обозначения ошибок проверки (ошибок конечного клиента). Например: отправка недопустимых полей приведет к ответу 422 Unprocessable Entity.
- **500 Internal server error** – Это общая ошибка сервера. Вероятно, ее не следует выдавать явно.
- **502 Bad Gateway** – Это указывает на недействительный ответ от вышестоящего сервера.
- **503 Service Unavailable** – Это указывает на то, что на стороне сервера произошло что-то неожиданное. Это может быть что угодно, например, перегрузка сервера, сбой некоторых частей системы.  
    

Мы должны выдавать ошибки, которые соответствуют проблеме, с которой столкнулось наше приложение. Коды ошибок должны сопровождаться сообщениями, чтобы у сопровождающих было достаточно информации для устранения проблемы. Тело ответа об ошибке должно предоставлять разработчику несколько вещей — полезное сообщение об ошибке, уникальный код ошибки (который можно найти для получения более подробной информации в документации) и, возможно, подробное описание. Вот несколько примеров:

```json
{
  "code" : 1234,
  "message" : "Something bad happened :(",
  "description" : "More details about the error here"
}
```

Ошибки проверки для **PUT, PATCH and POST** запросы будут _**need a field breakdown**_ . Лучше всего это моделировать, используя фиксированный код ошибки верхнего уровня для сбоев проверки и предоставляя подробные ошибки в дополнительном поле ошибок, например:

```json
{
  "code" : 1024,
  "message" : "Validation Failed",
  "errors" : [
    {
      "code" : 5432,
      "field" : "first_name",
      "message" : "First name cannot have fancy characters"
    },
    {
       "code" : 5622,
       "field" : "password",
       "message" : "Password cannot be blank"
    }
  ]
}
```

Всякий раз, когда наш API не завершает работу успешно, мы должны корректно завершить ее, отправив сообщение об ошибке с информацией, которая поможет пользователям принять корректирующие меры.

### 6. Secure REST APIs and maintain good security practices

Приведенные ниже пункты могут служить контрольным списком для проектирования механизма безопасности для REST API.

- **Keep it Simple**  
    Защитите API/систему — насколько она должна быть защищена. Каждый раз, когда вы делаете решение более сложным «без необходимости», вы также, скорее всего, оставляете дыру.
    
- **Always Use HTTPS**  
    Используя SSL, учетные данные аутентификации можно упростить до случайно сгенерированного токена доступа. Токен доставляется в поле имени пользователя HTTP Basic Auth. Он относительно прост в использовании, и вы получаете множество функций безопасности бесплатно.
    
- **Use Password Hash**  
    Пароли всегда должны быть хэшированы, чтобы защитить систему (или минимизировать ущерб), даже если она будет скомпрометирована при некоторых попытках взлома. Существует много таких алгоритмов хэширования, которые могут оказаться действительно эффективными для безопасности паролей, например, алгоритмы PBKDF2, bcrypt и scrypt.
    
- **Never expose information on URIs**  
    Имена пользователей, пароли, токены сеансов и ключи API не должны отображаться в URI, поскольку они могут быть зафиксированы в журналах веб-сервера, что делает их легкодоступными для злоумышленников.
    
    ```bash
    https://api.domain.com/user-management/users/{id}/someAction?apiKey=abcd123456789  //Very BAD !!
    ```
    
    Вышеуказанный URI раскрывает ключ API. Поэтому никогда не используйте эту форму безопасности.
    
- **Consider OAuth:**  
    Хотя базовая аутентификация достаточно хороша для большинства API и при правильной реализации также безопасна, но вы можете рассмотреть и OAuth. Фреймворк авторизации OAuth 2.0 позволяет стороннему приложению получать ограниченный доступ к HTTP-сервису либо от имени владельца ресурса, организуя взаимодействие по одобрению между владельцем ресурса и HTTP-сервисом, либо позволяя стороннему приложению получать доступ от его имени.
    
- **Consider Adding Timestamp in Request:**  
    Наряду с другими параметрами запроса вы можете добавить временную метку запроса как пользовательский заголовок HTTP в запросах API. Сервер сравнит текущую временную метку с временной меткой запроса и примет запрос только в том случае, если он находится после разумного периода времени (возможно, 30 секунд). Это предотвратит самые простые атаки повторного воспроизведения от людей, которые пытаются взломать вашу систему методом подбора, не меняя эту временную метку.
    
- **Input Parameter Validation:**  
    Проверяйте параметры запроса на самом первом шаге, до того, как он достигнет логики приложения. Используйте строгие проверки и немедленно отклоняйте запрос, если проверка не пройдена. В ответе API отправляйте соответствующие сообщения об ошибках и примеры правильного формата ввода для улучшения пользовательского опыта.
    

### 7. Cache data to improve performance

Кэшируемость является одним из архитектурных ограничений REST.

- **GET** Запросы должны быть кэшируемыми по умолчанию – пока не возникнет особое условие. Обычно браузеры рассматривают все запросы GET как кэшируемые.
- **POST** Запросы по умолчанию не кэшируются, но их можно сделать кэшируемыми, если к ответу добавить заголовок Expires или заголовок Cache-Control с директивой, явно разрешающей кэширование.
- Ответы на **PUT and DELETE** запросы вообще не кэшируются.  
    

Ниже приведены основные заголовки HTTP-ответа, которые мы можем использовать для управления поведением кэширования:

- **Expires**  
    HTTP-заголовок Expires указывает абсолютное время истечения срока действия кэшированного представления. По истечении этого времени кэшированное представление считается устаревшим и должно быть повторно проверено исходным сервером. Чтобы указать, что представление никогда не истекает, служба может включить время до одного года в будущем.
    
    ```yaml
    Expires: Fri, 20 May 2016 19:20:49 GMT
    ```
    
- **Cache-Control**  
    Значение заголовка состоит из одной или нескольких директив, разделенных запятыми. Эти директивы определяют, можно ли кэшировать ответ, и если да, то кем и как долго, например, директивы max-age или s-maxage.
    
    ```lua
    Cache-Control: max-age=3600
    ```
    

Кэшируемые ответы (на запросы GET или POST) также должны включать валидатор — заголовок ETag или Last-Modified.

- **ETag**  
    Значение ETag — это непрозрачный строковый токен, который сервер связывает с ресурсом для уникальной идентификации состояния ресурса в течение его жизненного цикла. Когда ресурс изменяется, ETag изменяется соответственно.
    
    ```vbnet
    ETag: "abcd1234567n34jv"
    ```
    
- **Last-Modified**  
    В то время как заголовок Date ответа указывает, когда был сгенерирован ответ, заголовок Last-Modified указывает, когда последний раз изменился связанный ресурс. Значение Last-Modified не может быть меньше значения Date.
    
    ```yaml
    Last-Modified: Fri, 10 May 2016 09:17:49 GMT
    ```
    

### 8. Use HATEOAS to enable navigation to related resources

Самая важная причина HATEOAS — это **loose coupling**. Если потребителю службы REST необходимо жестко закодировать все URI ресурсов, то он тесно связан с реализацией вашей службы. Вместо этого, если вы возвращаете URI, которые он может использовать для действий, то он слабо связан. Нет жесткой зависимости от структуры URI, так как она указывается и используется из ответа. При проектировании службы RESTful необходимо указать, как возвращать данные и ссылки, соответствующие запросу. HATEOAS — это простой способ, который обеспечивает простой и последовательный способ создания гиперссылок между ресурсами в вашем API REST.
# Задача о Праздничной Вечеринке: жадный Алгоритм

## Введение

Задача о праздничной вечеринке представляет собой классическую задачу выбора подмножества узлов в дереве, где каждый
узел представляет сотрудника, а ребра представляют иерархические отношения (начальник-подчиненный). Цель состоит в том,
чтобы выбрать максимальное количество сотрудников для участия в вечеринке с условием, что ни один начальник и его
подчиненный не могут одновременно присутствовать на мероприятии.

## Описание Задачи

Дано дерево, где каждый узел представляет сотрудника, и ребра представляют иерархические отношения (
начальник-подчиненный). Необходимо выбрать максимальное количество сотрудников для участия в вечеринке, при условии, что
ни один начальник и его непосредственный подчиненный не могут быть одновременно выбраны.

## Жадный Алгоритм и Доказательство Оптимальности

### Алгоритм

1. **Выбор Листьев**: Начинаем с выбора всех листьев (сотрудников без подчиненных).
2. **Удаление Выбранных и Их Родителей**: После выбора листьев удаляем выбранных листьев и их родителей из дерева.
3. **Повторение**: Повторяем процесс выбора листьев и удаления выбранных узлов и их родителей до тех пор, пока в дереве
   не останется узлов.

### Доказательство Оптимальности

Для доказательства оптимальности жадного алгоритма рассмотрим следующие случаи:

- **Базовый случай**: Если дерево состоит из одного узла (листа), то выбор этого узла является оптимальным.

- **Индуктивный шаг**: Предположим, что алгоритм работает оптимально для всех деревьев с меньшим числом узлов.
  Рассмотрим дерево с корнем `A` и дочерними узлами `B`, `C`, `D`, где `B`, `C`, `D` являются листьями. Выбираем
  листья `B`, `C`, `D` и удаляем их и их родителя `A`. Затем рассматриваем оставшееся дерево и повторяем процесс. Сумма
  выбранных листьев и оптимального решения для оставшегося дерева дает оптимальное решение для всего дерева.

## Примеры и Графическое Представление

### Пример 1: Звезда

- A (корень)
    - B (лист)
    - C (лист)
    - D (лист)

**Решение**:

- Выбираем листья B, C, D.
- Удаляем B, C, D и их родителя A.
- Нет оставшихся узлов.
- Выбранные узлы: B, C, D.

### Пример 2: Цепочка

- A (корень)
    - B
        - C
            - D (лист)

**Решение**:

- Выбираем лист D.
- Удаляем D и его родителя C.
- Выбираем B.
- Удаляем B и его родителя A.
- Выбранные узлы: D, B.

## Реализация на Java и Python

### Java

```java
import java.util.*;

class TreeNode {
    int val;
    List<TreeNode> children;

    public TreeNode(int val) {
        this.val = val;
        this.children = new ArrayList<>();
    }
}

public class PartyProblem {
    public static List<Integer> selectParticipants(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        selectLeaves(root, result);
        return result;
    }

    private static void selectLeaves(TreeNode node, List<Integer> result) {
        if (node.children.isEmpty()) {
            result.add(node.val);
            return;
        }
        for (TreeNode child : node.children) {
            selectLeaves(child, result);
        }
        // Remove leaves and their parents after selection
        node.children.clear();
    }

    public static void main(String[] args) {
        // Создание дерева
        TreeNode root = new TreeNode(1);
        TreeNode child1 = new TreeNode(2);
        TreeNode child2 = new TreeNode(3);
        TreeNode child3 = new TreeNode(4);
        root.children.add(child1);
        root.children.add(child2);
        root.children.add(child3);
        TreeNode grandchild = new TreeNode(5);
        child2.children.add(grandchild);

        List<Integer> participants = selectParticipants(root);
        System.out.println("Выбранные участники: " + participants);
    }
}
```

### Python

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.children = []


def select_participants(root, result):
    if not root.children:
        result.append(root.val)
        return
    for child in root.children:
        select_participants(child, result)
    # Remove leaves and their parents after selection
    root.children = []


def main():
    # Создание дерева
    root = TreeNode(1)
    child1 = TreeNode(2)
    child2 = TreeNode(3)
    child3 = TreeNode(4)
    root.children = [child1, child2, child3]
    grandchild = TreeNode(5)
    child2.children = [grandchild]

    participants = []
    select_participants(root, participants)
    print("Выбранные участники:", participants)


if __name__ == "__main__":
    main()
```

## Оценка Вычислительной Сложности

### Временная Сложность

- **Выбор листьев и удаление**: $O(n)$, где $n$ - количество узлов в дереве.
- **Итеративный процесс**: Процесс повторяется до тех пор, пока не будут выбраны все листья и удалены соответствующие
  узлы.

### Общая Временная Сложность

$O(n)$, так как каждый узел обрабатывается один раз.

## Заключение

Задача о праздничной вечеринке, основанная на дереве начальников и подчиненных, успешно решается с помощью жадного
алгоритма, который выбирает все листья и итеративно удаляет их и их родителей. Этот подход обеспечивает оптимальное
решение для дерева, что подтверждается как индуктивным доказательством, так и практическими примерами. Реализации на
Java и Python демонстрируют эффективность и простоту алгоритма, который может быть легко адаптирован для различных
структур данных и задач оптимизации.
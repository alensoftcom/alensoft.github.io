## Доказательство скорости обработки алгоритма НВП с использованием бинарного поиска

### Введение

Алгоритм нахождения наибольшей возрастающей подпоследовательности (НВП) с использованием бинарного поиска имеет временную сложность \( O(n \log n) \), где \( n \) — длина входного массива. В этом доказательстве мы рассмотрим, как достигается такая эффективность.

### Описание алгоритма

Алгоритм использует массив `tails`, где `tails[i]` хранит минимальное значение последнего элемента возрастающей подпоследовательности длины \( i+1 \). Для каждого элемента `x` из входного массива выполняется бинарный поиск по массиву `tails`, чтобы найти наименьший элемент, который больше или равен `x`. Если такой элемент найден, он заменяется на `x`. В противном случае `x` добавляется в конец массива `tails`, увеличивая длину НВП.

### Анализ сложности

1. **Инициализация массива `tails`**:
- Инициализация массива `tails` занимает \( O(n) \) времени, так как мы просто создаем массив размером \( n \).

2. **Проход по входному массиву**:
- Мы проходим по каждому элементу входного массива один раз, что занимает \( O(n) \) времени.

3. **Бинарный поиск**:
- Для каждого элемента `x` мы выполняем бинарный поиск в массиве `tails`. Бинарный поиск имеет временную сложность \( O(\log k) \), где \( k \) — текущая длина массива `tails`.
- В худшем случае, длина массива `tails` может достигать \( n \), поэтому бинарный поиск будет выполняться за \( O(\log n) \) времени.

4. **Обновление массива `tails`**:
- Обновление массива `tails` после каждого бинарного поиска занимает \( O(1) \) времени.

### Суммарная сложность

Таким образом, суммарная временная сложность алгоритма составляет:

\[
O(n) + O(n \cdot \log n) + O(n) = O(n \log n)
\]

- \( O(n) \) — инициализация массива `tails`.
- \( O(n \cdot \log n) \) — проход по входному массиву и выполнение бинарного поиска для каждого элемента.
- \( O(n) \) — обновление массива `tails`.

### Заключение

Алгоритм нахождения НВП с использованием бинарного поиска имеет временную сложность \( O(n \log n) \), что делает его эффективным для больших входных данных. Это достигается за счет использования бинарного поиска для обновления массива `tails`, что позволяет сократить время поиска места для вставки нового элемента.
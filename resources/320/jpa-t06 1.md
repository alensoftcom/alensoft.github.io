# Hibernate Caching

## Материалы
+ Обзор
+ First Level Cache
+ Second Level Cache
+ Query Level Cache

## Обзор

Кэширование — это функция, которая используется в приложениях для повышения производительности. Кэш располагается между базой данных и приложением, и обычно данные запросов к базе данных кэшируются (локальная копия) на диске или в памяти, так что последующие вызовы тех же данных могут обслуживаться только кэшем. Кэширование также важно для Hibernate. Он использует многоуровневую схему кэширования, как описано ниже.  
![](http://localhost:24100/media/320-03.png)  
Кэш Hibernate имеет 3 уровня кэширования:

- Кэш первого уровня (First-level cache)
- Кэш второго уровня (кэш второго уровня)
- Кэш запросов

## First Level Cache

Кэш первого уровня Hibernate связан с **Session object**. Кэш первого уровня Hibernate включен по умолчанию, и нет возможности его отключить. Однако hibernate предоставляет методы, с помощью которых мы можем удалить выбранные объекты из кэша или полностью очистить кэш. Любой объект, кэшированный в сеансе, не будет виден другим сеансам, и когда сеанс закрывается, все кэшированные объекты также будут потеряны.

## Second Level Cache

Кэш второго уровня может быть включен для области процесса или кластера. В этом кэше состояние постоянного объекта хранится (в разобранном) виде, а не как полный экземпляр. Кэш второго уровня является необязательным и может быть настроен для кэширования на уровне класса, коллекции. Очень важно знать, что кэш второго уровня находится на уровне **SessionFactory level**, что означает, что все сеансы одной и той же фабрики сеансов будут совместно использовать данные кэша.  

Hibernate не предоставляет никакой реализации по умолчанию для кэша второго уровня. Он дает **CacheProvider** интерфейс (интерфейс org.hibernate.cache.CacheProvider). Таким образом, любой сторонний кэш, который реализует **CacheProvider interface** может быть подключен как кэш второго уровня:

- EHCache
- OSCache
- SwarmCache
- JBoss TreeCache

Стратегии параллелизма: Основная обязанность стратегии параллелизма — хранить и извлекать данные из кэша. Существует четыре встроенных стратегии параллелизма:

- **Read Only** – как следует из названия, он подходит для данных, которые никогда не меняются, например, для справочных данных (например, для месяца в году)
- **Non Strict Read Write** – высокая вероятность того, что мы можем прочитать устаревшие данные и несоответствие между базой данных и кэшем. Следует использовать, когда данные почти не меняются.
- **Read-Write** - эта стратегия поддерживает уровень изоляции read-committed (чтение зафиксированных данных) и недоступна в кластерных средах.
- **Transactional** - предотвращает появление устаревших данных, поэтому его следует использовать, когда устаревшие данные вообще недопустимы.

  
Ему нужно сообщить самому hibernate, что именно кэшировать. К счастью, это можно сделать очень легко с помощью аннотаций, например:

```java
@Entity
@Table(name = "customer")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Customer {
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "order")
    private List<Order> orders = new ArrayList<>();
    // ...
}
```

Зависимости классов не отлавливаются по умолчанию. Например, если мы рассмотрим класс выше - Customer, то при выборке коллекция заказов будет взята из базы данных, а не из кэша второго уровня. Если вы хотите кэшировать также и зависимости, то класс должен выглядеть так:

```java
@Entity
@Table(name = "customer")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Customer {
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "order")
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private List<Order> orders = new ArrayList<>();
    // ...
}
```

**How it works**: Когда сеанс hibernate пытается загрузить сущность, он сначала находит ее в кэше первого уровня, если не находит, то ищет в кэше второго уровня и возвращает ответ (если он доступен), но перед возвратом ответа он также сохраняет этот объект/данные на первом уровне, чтобы в следующий раз не нужно было переходить на уровень сеанса. Если данные не найдены на втором уровне, он обращается к базе данных для извлечения данных. Перед возвратом ответа пользователю он сохраняет этот объект/данные на обоих уровнях кэша, чтобы в следующий раз они были доступны только на этапах кэша.

## Query Level Cache

По умолчанию данные запросов HQL не кэшируются. Если приложение запускает оператор HQL в одном и том же или разных сеансах несколько раз, то данные запроса могут кэшироваться.

Для этого нам нужно включить, нам нужно сначала установить **_hibernate.cache.use_query_cache="true"_** в _**hibernate.cfg.xml file**_ . Настройка этого свойства создаст два дополнительных требуемых региона кэша. Один для хранения данных и один для хранения последних обновленных временных меток.

```xml
<property name="hibernate.cache.use_query_cache" value="true"/>
```

После этого нам нужно явно вызвать **_setCacheable(true)_** на объекте запроса перед выполнением:

```java
Query query = session.createQuery("select c from Customer c where c.name = ?");
query.setCacheable(true);
```

Кэш запросов похож на кэш второго уровня. Но в отличие от него ключом к данным кэша является не идентификатор объекта, а набор параметров запроса. А сами данные — это идентификаторы объектов, соответствующих критериям запроса. Таким образом, рационально использовать этот кэш совместно с кэшем второго уровня.
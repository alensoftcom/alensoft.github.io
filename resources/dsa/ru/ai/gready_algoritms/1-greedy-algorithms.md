# Жадные Алгоритмы

## Введение

Жадные алгоритмы представляют собой класс алгоритмов, которые делают локально оптимальные выборы на каждом этапе с
надеждой, что эти выборы приведут к глобально оптимальному решению. Эти алгоритмы широко применяются в различных
областях, таких как оптимизация, теория графов, теория кодирования и др. Жадные алгоритмы часто просты в реализации и
эффективны в вычислительном отношении, хотя их корректность может быть непростой для доказательства.

## Основные Понятия и Принципы

### Определение

Жадный алгоритм строит решение пошагово, на каждом шаге выбирая тот вариант, который кажется лучшим на данный момент.
Этот выбор часто основан на некотором жадном критерии, который стремится максимизировать или минимизировать некоторую
функцию.

### Свойства

1. **Жадный Выбор**: Алгоритм делает выбор, который кажется оптимальным на данный момент, не заботясь о последствиях
   этого выбора в будущем.

2. **Оптимальная Подструктура**: Оптимальное решение задачи содержит в себе оптимальные решения подзадач.

### Математическая Формулировка

Пусть дана задача оптимизации, где необходимо найти решение $S$ из множества допустимых решений $C$, такое что функция
цели $f(S)$ достигает экстремума (максимума или минимума). Жадный алгоритм строит решение пошагово, добавляя на каждом
шаге элемент $x_i$ из множества кандидатов $X$, который оптимизирует некоторую промежуточную функцию $g(S \cup
\{x_i\})$.

### Примеры Задач

#### 1. Задача о Заданиях (Activity Selection Problem)

**Формулировка**: Дано множество заданий, каждое задание имеет начало $s_i$ и конец $f_i$. Необходимо выбрать
максимальное множество непересекающихся заданий.

**Жадный Критерий**: Каждый раз, когда выбирается задание с самым ранним временем окончания, затем выбирается следующее
задание, не конфликтующее с ним, и так далее.

**Алгоритм**:

1. Сортировать задания по времени окончания.
2. Инициализировать множество выбранных заданий $S = \emptyset$.
3. Для каждого задания в отсортированном порядке:
    - Если задание не конфликтует с последним выбранным заданием, добавить его в $S$.

**Вычислительная Сложность**: $O(n \log n)$, где $n$ — количество заданий (из-за сортировки).

#### 2. Задача о кодировании Хаффмана (Huffman Coding)

**Формулировка**: Необходимо построить префиксный код для символов с заданными частотами, минимизирующий среднюю длину
кодового слова.

**Жадный Критерий**: На каждом шаге объединять два символа с наименьшей частотой.

**Алгоритм**:

1. Создать priority queue с символами и их частотами.
2. Пока в очереди более одного элемента:
    - Извлечь два символа с наименьшей частотой.
    - Создать новый символ, являющийся их объединением, с частотой равной сумме их частот.
    - Добавить новый символ обратно в очередь.
3. Построить дерево кодирования.

**Вычислительная Сложность**: $O(n \log n)$, где $n$ — количество символов (из-за использования priority queue).

#### 3. Задача о Минимальном Оspaнном Дереве (Minimum Spanning Tree, MST)

**Формулировка**: Дан неориентированный взвешенный граф. Необходимо найти минимальное остовое дерево, т.е. подграф,
соединяющий все вершины с минимальным суммарным весом ребер.

О́стовное де́рево графа (англ. Spanning tree) — это дерево, подграф данного графа, с тем же числом вершин,
что и у исходного графа. Неформально говоря, остовное дерево получается из исходного графа удалением максимального числа
рёбер, входящих в циклы, но без нарушения связности графа. Остовное дерево включает в себя все
$n$ вершин исходного графа и содержит $n − 1$ ребро.

**Жадный Критерий**: На каждом шаге выбирать ребро с минимальным весом, которое не образует цикл.

**Алгоритм Крускала (Kruskal's Algorithm)**:

1. Сортировать все ребра по возрастанию веса.
2. Инициализировать disjoint-set structure для отслеживания связных компонент.
3. Проходить по ребрам в порядке возрастания веса и добавлять ребро в MST, если оно соединяет две разных компоненты.

**Вычислительная Сложность**: $O(E \log E)$, где $E$ — количество ребер (из-за сортировки).

**Алгоритм Прима (Prim's Algorithm)**:

1. Инициализировать MST с любой начальной вершиной.
2. На каждом шаге добавлять ребро с минимальным весом, соединяющее MST с оставшимся графом.
3. Повторять до тех пор, пока не будут соединены все вершины.

**Вычислительная Сложность**: $O(E \log V)$, где $V$ — количество вершин (с использованием priority queue).

## Доказательство Корректности Жадных Алгоритмов

Доказательство корректности жадных алгоритмов часто основывается на двух ключевых свойствах: **жадном выборе** и *
*оптимальной подструктуре**.

### Оптимальная Подструктура

Для того чтобы жадный алгоритм работал корректно, необходимо, чтобы оптимальное решение задачи содержало оптимальные
решения подзадач. Это свойство часто доказывается с помощью метода "от противного", предполагая, что оптимальное решение
не содержит оптимального решения подзадачи, и показывая, что это приводит к противоречию.

### Жадный Выбор

Для доказательства того, что жадный выбор ведет к оптимальному решению, часто используется индуктивный метод.
Предполагается, что после $k$ шагов жадного выбора, текущее решение является оптимальным для первых $k$ шагов. Затем
показывается, что выбор на $(k+1)$-ом шаге также приводит к оптимальному решению для первых $(k+1)$ шагов.

### Пример Доказательства: Задача о Заданиях

Рассмотрим задачу о заданиях. Пусть $S$ — множество непересекающихся заданий, отсортированных по времени окончания.
Докажем, что $S$ содержит максимальное число заданий.

**База Индукции**: Для первого задания, оно является оптимальным выбором, так как имеет наименьшее время окончания.

**Индуктивный Шаг**: Пусть для первых $k$ заданий выбор оптимален. Рассмотрим $(k+1)$-ое задание. Так как оно не
конфликтует с предыдущим, и имеет наименьшее время окончания среди доступных, то выбор является оптимальным.

## Сравнение с Динамическим Программированием

Жадные алгоритмы и динамическое программирование (ДП) являются двумя основными подходами к решению задач оптимизации.
Жадные алгоритмы строят решение пошагово, делая локально оптимальные выборы, в то время как ДП строит решение, запоминая
оптимальные решения подзадач.

### Критерии Выбора

- **Жадные Алгоритмы**: Подходят для задач, в которых можно сделать локально оптимальный выбор, гарантирующий глобальную
  оптимальность.

- **Динамическое Программирование**: Подходит для задач, в которых оптимальное решение можно построить из оптимальных
  решений подзадач, но локальный выбор не гарантирует глобальную оптимальность.

### Пример: Задача о Рюкзаке

- **Жадный Алгоритм**: Выбор предметов на основе соотношения стоимость/вес может не привести к оптимальному решению.

- **Динамическое Программирование**: Гарантирует оптимальное решение, но с большей вычислительной сложностью.

## Заключение

Жадные алгоритмы являются мощным инструментом в арсенале алгоритмического программирования. Они позволяют эффективно
решать широкий спектр задач оптимизации, обеспечивая простоту реализации и высокую вычислительную эффективность. Однако
их применение требует тщательного анализа корректности, так как жадный выбор не всегда ведет к глобальной оптимальности.

## Литература

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT
   Press.
2. Dasgupta, S., Papadimitriou, C. H., & Vazirani, U. V. (2008). *Algorithms*. McGraw-Hill.
3. Kozen, D. C. (1992). *The Design and Analysis of Algorithms*. Springer-Verlag.

